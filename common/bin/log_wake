#!/usr/bin/python

from __future__ import print_function

try:
    from urllib import pathname2url
except:
    from urllib.request import pathname2url

from contextlib import closing
import argparse
import datetime
import json
import os
import webbrowser
import sqlite3
import tempfile

# DEBUG
from pprint import pprint

# TODO: Add date ranges

HTML_TEMPLATE = """
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>{title}</title>
    <link rel="stylesheet" href="stylesheet.css" type="text/css">
</head>
<body>
    <div id="timeline"></div>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="https://raw.githubusercontent.com/jiahuang/d3-timeline/master/src/d3-timeline.js"></script>
    <!-- Will contain one or more graphs -->
    {script}
</body>
</html>
"""

SCRIPT_TEMPLATE = """
    <script>
        var width = window.innerWidth || document.body.clientWidth;
        var testData = {data};
        var chart = d3.timeline().beginning({beginning}).ending({ending}).showToday();
        var svg = d3.select("#timeline").append("svg").attr("width", width).datum(testData).call(chart);
    </script>
"""

sqlite3.register_adapter(bool, int)
sqlite3.register_converter("BOOLEAN", lambda v: bool(int(v)))


# d3-timeline uses milliseconds since epoch
def get_timestamp(dt):
    epoch = datetime.datetime.utcfromtimestamp(0)
    # adjust our timestamp to deal with timezone differences
    dt = dt + datetime.timedelta(hours=5)
    return int((dt - epoch).total_seconds() * 1000)


def insert_into_db(db_path, awake):
    with closing(sqlite3.connect(db_path, detect_types=sqlite3.PARSE_DECLTYPES)) as conn:
        # http://stackoverflow.com/a/16936992/2958070

        cur = conn.cursor()

        cur.execute('''CREATE TABLE IF NOT EXISTS Wake(moment TIMESTAMP PRIMARY KEY, awake BOOLEAN)''')

        # check if the last wake value is not the current awake value. These should toggle
        last = list(cur.execute('SELECT moment, awake FROM wake ORDER BY DATETIME(moment) DESC LIMIT 1'))

        if last:  # there is something in the table
            if last[0][1] == awake:  # if it's not toggling, abort ship!
                if awake:
                    raise SystemExit("Already awake! Cancelling...")
                else:
                    raise SystemExit("Already asleep! Cancelling...")

        cur.execute('INSERT INTO Wake(moment, awake) values (?, ?)', (datetime.datetime.now(), awake))

        conn.commit()


# This will eventually take arguments so I can get dates...
def get_dates_range_from_db(db_path, start_day, end_day):
    with closing(sqlite3.connect(db_path, detect_types=sqlite3.PARSE_DECLTYPES)) as conn:
        cur = conn.cursor()
        start_day = start_day.replace(hour=0, minute=0, second=0)
        end_day = end_day.replace(hour=23, minute=59, second=59)
        datetimes = list(cur.execute('SELECT moment, awake from Wake WHERE moment >= ? AND moment <= ? ORDER BY DATETIME(moment) ASC', (start_day, end_day)))
        pprint(datetimes)


# TODO: work this out and add it to the argumentparser
def get_dates_period_from_db(db_path, period):
    if period == 'd':
        pass
    elif period == 'w':
        pass
    elif period == 'm':
        pass
    elif period == 'a':
        pass
    else:
        raise ValueError("`period` must be 'd', 'w', 'm', or 'a'. Not %r, silly" % period)


def graph(db_path):

    # TODO:
    # Use get_dates_from_db to get dates
    # use groupby to get them by day
    # make and normalize starts and ends
    # get the min and max of all of the days
    # write and insert the JS to make the charts
    with closing(sqlite3.connect(db_path, detect_types=sqlite3.PARSE_DECLTYPES)) as conn:
        cur = conn.cursor()
        starts = list(cur.execute('SELECT moment from Wake WHERE awake = 1 ORDER BY DATETIME(moment) ASC'))
        starts = [entry[0] for entry in starts if entry[0].day == datetime.datetime.today().day]

        ends = list(cur.execute('SELECT moment from Wake WHERE awake = 0 ORDER BY DATETIME(moment) ASC'))
        ends = [entry[0] for entry in ends if entry[0].day == datetime.datetime.today().day]

        # make sure the first wake is before the first sleep
        # and the last sleep is after the last wake

        # TODO: refactor this (can probably just move the second if up)
        # if this is the first time, ends will be empty. Add it
        if not ends:
            ends.append(datetime.datetime.now())
        if starts[0] > ends[0]:
            del ends[0]
        if starts[-1] > ends[-1]:
            ends.append(datetime.datetime.now())
        assert len(starts) == len(ends)
        assert all(s < e for s, e in zip(starts, ends))

        times = [dict(starting_time=get_timestamp(s), ending_time=get_timestamp(e))
                 for s, e in zip(starts, ends)]

        today_times = [{'label': str(datetime.datetime.today()), 'times': times}]

        # these are for the graph beginning at 7 and ending at 6
        beginning = get_timestamp(starts[0].replace(hour=7, minute=0))
        ending = get_timestamp(ends[0].replace(hour=18, minute=0))

        # print(json.dumps(today_times, indent=2))
        # Note: on Mac this can fill /var/folders/...
        tmp = tempfile.NamedTemporaryFile(prefix='log_wake', suffix='.html', delete=False)
        print(tmp.name)
        with open(tmp.name, 'w') as html:
            script_string = SCRIPT_TEMPLATE.format(data=json.dumps(today_times, indent=2),
                                                   beginning=beginning,
                                                   ending=ending)
            html_string = HTML_TEMPLATE.format(title=datetime.datetime.today(),
                                               script=script_string)
            print(html_string, file=html)

    webbrowser.open('file:{}'.format(pathname2url(tmp.name)))


def list_times(db_path):
    # TODO: use get_dates_from_db
    with closing(sqlite3.connect(db_path, detect_types=sqlite3.PARSE_DECLTYPES)) as conn:
        cur = conn.cursor()
        cur.execute('SELECT moment, awake FROM Wake ORDER BY DATETIME(moment) ASC')
        for (moment, awake) in cur:
            # %a -> abbreviated weekday
            print(moment.strftime('%a'), moment, 'wake' if awake else 'sleep')


def main():
    # create the top-level parser
    # TODO: rejigger this so the timeframe can be the period too. Add 'a'
    parser = argparse.ArgumentParser(description='Log waking and sleeping')
    parser.add_argument('--database', '-db',
                        default='~/.sleepwatch.sqlite3',
                        help='database to use')

    subparsers = parser.add_subparsers(dest='subcommand')
    subparsers.required = True

    list_parser = subparsers.add_parser('list',
                                        help='list wakings and sleepings')
    list_parser.add_argument('--timeframe', '-t',
                             default='w',
                             choices=['d', 'w', 'm'],
                             help="[d]ay, [w]eek, [m]onth")

    graph_parser = subparsers.add_parser('graph',
                                         help='graph wakings and sleepings')
    graph_parser.add_argument('--timeframe', '-t',
                              default='w',
                              choices=['d', 'w', 'm'],
                              help="[d]ay, [w]eek, [m]onth")

    subparsers.add_parser('wake',
                          help='log wakeup')
    subparsers.add_parser('sleep',
                          help='log sleep')

    # Finally parse and deal with the parsed arguments
    args = parser.parse_args()
    database = os.path.expanduser(args.database)

    if args.subcommand == 'wake':
        insert_into_db(database, True)
    elif args.subcommand == 'sleep':
        insert_into_db(database, False)
    elif args.subcommand == 'graph':
        graph(database)
    elif args.subcommand == 'list':
        list_times(database)
    else:
        raise SystemExit("How did you evade the argparser?")


if __name__ == '__main__':
    main()
    # db_path = '~/.sleepwatch.sqlite3'
    # database = os.path.expanduser(db_path)
    # get_dates_from_db(database, datetime.datetime.now(), datetime.datetime.now())
